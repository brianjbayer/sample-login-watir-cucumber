#!/bin/sh

# Project Commands
be='bundle exec'
lint_cmd="${be} rubocop"
secscan_cmd="${be} bundle-audit check --update"
tests_cmd="${be} cucumber"
parallel_tests_cmd="${be} parallel_cucumber"

usage() {
  cat << USAGE
Usage: $0 [-hp] [CMD] [ARG...]
This is the project "run" script, executing common application tasks.

If the CMD is not recognized, it runs all arguments as a command:
  * lint:           Run the linter [$lint_cmd]

  * secscan:        Run the security scanner [$secscan_cmd]

  * tests:          Run the tests (cucumber) [$tests_cmd]
                    (in parallel if -p specified) [$parallel_tests_cmd]

  * [CMD] [ARG...]: Run any other command with arguments

OPTIONS: (in override order)
  -h: Show this help message
  -p: if supported by the CMD, runs in parallel
USAGE
}

# --- Functions ---

run_and_exit_return_code () {
  # Exit script on any errors
  set -e

  # Set to all positional parameters each expanding
  # to a separate word
  command_to_run="$@"
  if [ -z "$command_to_run" ]; then
    echo "ERROR: Function requires a command argument (86)"
    exit 86
  fi

  # Run the command and preserve exit code
  echo "RUNNING [${command_to_run} ]..."
  # Allow to fail but catch return code
  set +e
  $command_to_run
  run_return_code=$?
  # NOTE return code must be caught before any other command
  set -e
  echo ''

  echo "EXITING WITH RUN RETURN CODE [${run_return_code}]"
  exit $run_return_code
}

# ------------
# --- MAIN ---
# ------------
# Exit script on any errors
set -e

while getopts ":hp" options; do
  case "${options}" in
    p)
      parallel=1
      ;;
    h)
      usage ; exit
      ;;
    \?)
      usage
      err_exit 1 "Invalid Option: -$OPTARG"
      ;;
  esac
done
shift $((OPTIND-1))

# set run command if recognized action
action="${1}"
case "$action" in
  "lint")
    shift
    run_command="${lint_cmd} $@"
  ;;

  "secscan")
    shift
    run_command="${secscan_cmd} $@"
  ;;

  "tests")
    shift
    run_command="${tests_cmd} $@"
    [ -n "${parallel}" ] && run_command="${parallel_tests_cmd} $@"
  ;;
esac

if [ -z "$run_command" ]; then
  # No recognized actions so run all the arguments as the command"
  run_command="$@"
else
  echo "RUNNING Action [${action}]"
fi

# Run the command and exit passing any arguments
run_and_exit_return_code "$run_command"
echo "ERROR: should have exited!!! (99)"
exit 99
