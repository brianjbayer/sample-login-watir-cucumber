#!/bin/sh

# --- Project Commands ---
# Running tests
tests='cucumber'
parallel_tests='parallel_cucumber'

# Code standards
lint='rubocop'
secscan='bundle-audit check --update'

be='bundle exec'
lint_cmd="${be} ${lint}"
secscan_cmd="${be} ${secscan}"
tests_cmd="${be} ${tests}"
parallel_tests_cmd="${be} ${parallel_tests}"

usage() {
  cat << USAGE
Usage: $0 [-hp] [COMMAND] [ARG...]
This is the project "run" script, executing common application tasks.

If the COMMAND is not recognized, it runs all arguments as a command:

COMMANDS:
  lint:     Run the linter [$lint_cmd]

  secscan:  Run the security scanner [$secscan_cmd]

  tests:    Run the tests [$tests_cmd]
            (in parallel if -p specified) [$parallel_tests_cmd]

  [COMMAND] [ARG...]: Run any other command with arguments

OPTIONS:
  -h: Show this help message
  -p: if supported by the COMMAND, runs in parallel
USAGE
}

# --- Functions ---
err_exit() {
  err_code=$1
  err_msg="$2"
  echo "${err_msg} (${err_code})" 1>&2
  exit $err_code
}

run_and_exit_return_code () {
  # Exit script on any errors
  set -e

  command_to_run="$@"
  [ -z "$command_to_run" ] && err_exit 1 "Missing argument"

  # Run the command and preserve exit code
  echo "RUNNING [${command_to_run} ]..."
  # Allow to fail but catch return code
  set +e
  $command_to_run
  run_return_code=$?
  # NOTE return code must be caught before any other command
  set -e
  echo ''

  echo "EXITING WITH RUN RETURN CODE [${run_return_code}]"
  exit $run_return_code
}

# --- MAIN ---
# Exit script on any errors
set -e

while getopts ":hp" options; do
  case "${options}" in
    p)
      parallel=1
      ;;
    h)
      usage ; exit
      ;;
    \?)
      usage
      err_exit 1 "Invalid Option: -$OPTARG"
      ;;
  esac
done
shift $((OPTIND-1))

# Set command to run if recognized COMMAND
command="${1}"

[ "$command" = 'lint' ] && run_command="${lint_cmd}"

[ "$command" = 'secscan' ] && run_command="${secscan_cmd}"

if [ "$command" = 'tests' ] ; then
  run_command="${tests_cmd}"
  [ -n "${parallel}" ] && run_command="${parallel_tests_cmd}"
fi

if [ -n "$run_command" ]; then
  shift
  run_command="${run_command} $@"
  echo "RUNNING COMMAND [${action}]"
else
# No recognized actions so run all the arguments as the command"
  run_command="$@"
fi

# Run the command and exit passing any arguments
run_and_exit_return_code "$run_command"
err_exit 99 "LOGIC ERROR"
